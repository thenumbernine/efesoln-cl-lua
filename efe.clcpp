#include "autogen.h"
#include "math.hpp"
#include "efe.h"

constant real const c = 299792458;			// m/s
constant real const G = 6.67384e-11;		// m^3 / (kg s^2)

constant int const sym3[3][3] = {
	{0, 1, 2},
	{1, 3, 4},
	{2, 4, 5},
};


constant int const sym4[4][4] = {
	{0, 1, 2, 3},
	{1, 4, 5, 6},
	{2, 5, 7, 8},
	{3, 6, 8, 9},
};

constant real const d1coeffs[] = {
	0,
<?
local d1coeffs = derivCoeffs[1][solver.diffOrder]
for i=1,#d1coeffs do
?>	<?=d1coeffs[i]?>,
<?
end
?>
};

real d1coeff_for_offset(int offset) {
	if (offset < 0) {
		return -real(offset) * d1coeffs[-offset];
	} else {
		return real(offset) * d1coeffs[offset];
	}
}

constant real const d2coeffs[] = {
<?
local d2coeffs = derivCoeffs[2][solver.diffOrder]
for i=0,#d2coeffs do
?>	<?=d2coeffs[i]?>,
<?
end
?>
};

//ε_ijk a_j b_k
real3 real3_cross(real3 const & a, real3 const & b) {
	return real3(
		a.y * b.z - a.z * b.y,
		a.z * b.x - a.x * b.z,
		a.x * b.y - a.y * b.x
	);
}

// ok weird convention ...
// for spacetime vars, real3 is xyz, real4 is used such that .s0123 == txyz (time dimension first)
// but for opencl vars (i, etc), real4 is named xyzw (time dimension last)
// this is going to assume the former (spacetime vars)
real3 real4_to_real3(real4 const & a) {
	return real3(a.s1, a.s2, a.s3);
}

real4 real3_to_real4(real3 const & a) {
	return real4(0, a.s0, a.s1, a.s2);
}

real real3s3_det(real3s3 const & m) {
	return m.s00 * m.s11 * m.s22
		+ m.s01 * m.s12 * m.s02
		+ m.s02 * m.s01 * m.s12
		- m.s02 * m.s11 * m.s02
		- m.s01 * m.s01 * m.s22
		- m.s00 * m.s12 * m.s12;
}

real3s3 real3s3_inv(real3s3 const & m, real const d) {
	real const invd = real(1) / d;
	return real3s3(
		(m.s11 * m.s22 - m.s12 * m.s12) * invd,
		(m.s02 * m.s12 - m.s01 * m.s22) * invd,
		(m.s01 * m.s12 - m.s02 * m.s11) * invd,
		(m.s00 * m.s22 - m.s02 * m.s02) * invd,
		(m.s02 * m.s01 - m.s00 * m.s12) * invd,
		(m.s00 * m.s11 - m.s01 * m.s01) * invd
	);
}

real4s4 real4s4_outer(real4 const & v) {
	return real4s4(
<? for a=0,3 do
	for b=a,3 do
?>		v.s<?=a?> * v.s<?=b?><?=(a < 3 or b < 3) and "," or ""?>
<? 	end
end
?>	);
}

real3 real4s4_i0(real4s4 const & a) {
	return real3(a.s01, a.s02, a.s03);
}

real3s3 real4s4_ij(real4s4 const & a) {
	return real3s3(
<?
for i=0,2 do
	for j=i,2 do
?>		a.s<?=i+1?><?=j+1?><?=(i < 2 or j < 2) and "," or ""?>
<?	end
end
?>	);
}

real real4s4_det(real4s4 const & m) {
	return
		m.s03 * m.s12 * m.s12 * m.s03 - m.s02 * m.s13 * m.s12 * m.s03 -
		m.s03 * m.s11 * m.s22 * m.s03 + m.s01 * m.s13 * m.s22 * m.s03 +
		m.s02 * m.s11 * m.s23 * m.s03 - m.s01 * m.s12 * m.s23 * m.s03 -
		m.s03 * m.s12 * m.s02 * m.s13 + m.s02 * m.s13 * m.s02 * m.s13 +
		m.s03 * m.s01 * m.s22 * m.s13 - m.s00 * m.s13 * m.s22 * m.s13 -
		m.s02 * m.s01 * m.s23 * m.s13 + m.s00 * m.s12 * m.s23 * m.s13 +
		m.s03 * m.s11 * m.s02 * m.s23 - m.s01 * m.s13 * m.s02 * m.s23 -
		m.s03 * m.s01 * m.s12 * m.s23 + m.s00 * m.s13 * m.s12 * m.s23 +
		m.s01 * m.s01 * m.s23 * m.s23 - m.s00 * m.s11 * m.s23 * m.s23 -
		m.s02 * m.s11 * m.s02 * m.s33 + m.s01 * m.s12 * m.s02 * m.s33 +
		m.s02 * m.s01 * m.s12 * m.s33 - m.s00 * m.s12 * m.s12 * m.s33 -
		m.s01 * m.s01 * m.s22 * m.s33 + m.s00 * m.s11 * m.s22 * m.s33;
}

constant real4s4 const real4s4_Minkowski = real4s4(
	-1, 0, 0, 0,
		1, 0, 0,
			1, 0,
				1
);


//a = b_ii
real real4x4_tr(real4x4 const & a) {
	return a.s0.s0 + a.s1.s1 + a.s2.s2 + a.s3.s3;
}

real3 real4x4s4_i00(real4x4s4 const & a) {
	return real3(a.s1.s00, a.s2.s00, a.s3.s00);
}

//b_i = a^j_ji
real4 real4x4s4_tr12(real4x4s4 const & a) {
	return real4(
<? for i=0,3 do
?>		0.<?
	for j=0,3 do
?> + a.s<?=j?>.s<?=sym(j,i)?><?
	end
?><?=i < 3 and "," or ""?>
<? end
?>	);
}

//b^i = a^ij_j
real4 real4x4x4_tr23(real4x4x4 const & a) {
	return real4(
		real4x4_tr(a.s0),
		real4x4_tr(a.s1),
		real4x4_tr(a.s2),
		real4x4_tr(a.s3)
	);
}

//c^i_jk = a^il b_ljk
real4x4s4 real4s4_real4x4s4_mul(
	real4s4 const & a,
	real4x4s4 const & b
) {
	real4x4s4 result;
	for (int i = 0; i < 4; ++i) {
		for (int jk = 0; jk < 10; ++jk) {
			real sum = {};
			for (int l = 0; l < 4; ++l) {
				sum += a.s[sym4[i][l]] * b.s[l].s[jk];
			}
			result.s[i].s[jk] = sum;
		}
	}
	return result;
}

//c^ij_k = a^i_mk b^mj
real4x4x4 real4x4s4_real4s4_mul21(
	real4x4s4 const & a,
	real4s4 const & b
) {
	return real4x4x4(
		b * a.s0,
		b * a.s1,
		b * a.s2,
		b * a.s3
	);
}

real4x4x4x4 real4x4x4x4_real4s4_mul_1_1(
	real4x4x4x4 const & a,
	real4s4 const & b
) {
	return real4x4x4x4(
<? for a=0,3 do
?>		real4x4x4(
<?	for b=0,3 do
?>			real4x4(
<?		for c=0,3 do
?>				real4(
<?			for d=0,3 do
?>					0.<?
				for e=0,3 do
?> + a.s<?=e?>.s<?=b?>.s<?=c?>.s<?=d?> * b.s<?=sym(e,a)?><?
				end
?>					<?=d < 3 and "," or ""?>
<?			end
?>				)<?=c < 3 and "," or ""?>
<?		end
?>			)<?=b < 3 and "," or ""?>
<? 	end
?>		)<?=a < 3 and "," or ""?>
<? end
?>	);
}

real4x4x4x4 real4x4x4x4_real4s4_mul_3_1(
	real4x4x4x4 const & a,
	real4s4 const & b
) {
	return real4x4x4x4(
<? for a=0,3 do
?>		real4x4x4(
<?	for b=0,3 do
?>			real4x4(
<?		for c=0,3 do
?>				real4(
<?			for d=0,3 do
?>					0.<?
				for e=0,3 do
?> + a.s<?=a?>.s<?=b?>.s<?=e?>.s<?=d?> * b.s<?=sym(e,c)?><?
				end
?>					<?=d < 3 and "," or ""?>
<?			end
?>				)<?=c < 3 and "," or ""?>
<?		end
?>			)<?=b < 3 and "," or ""?>
<? 	end
?>		)<?=a < 3 and "," or ""?>
<? end
?>	);
}

//b_ij = a^k_ikj
// assuming b_ij = b_ji i.e. a_ijkl = a_klij
real4s4 real4x4x4x4_tr13_to_real4s4(real4x4x4x4 const & a) {
	return real4s4(
<? for a=0,3 do
	for b=a,3 do
?>		real() <?
		for c=0,3 do
?> + a.s<?=c?>.s<?=a?>.s<?=c?>.s<?=b?><?
		end ?><?=(a < 3 or b < 3) and "," or ""?>
<? 	end
end
?>	);
}

real3 getX(
	constant env_t const * const env,
	int4 const i
) {
	return real3(
		env->xmin.x + (real(i.x) + .5)/real(env->size.x) * (env->xmax.x - env->xmin.x),
		env->xmin.y + (real(i.y) + .5)/real(env->size.y) * (env->xmax.y - env->xmin.y),
		env->xmin.z + (real(i.z) + .5)/real(env->size.z) * (env->xmax.z - env->xmin.z)
	);
}

constant int4 const int4_dirs[3] = {
	(int4)(1, 0, 0, 0),
	(int4)(0, 1, 0, 0),
	(int4)(0, 0, 1, 0),
};
int4 int4_dir(int const dim, int const offset) {
	return int4_dirs[dim] * offset;
}

//put the boundary condition code in here, in one place
// this is hardcoded to g_ab = η_ab at boundaries
gPrim_t calc_gPrim_boundary(
	constant env_t const * const env,
	global gPrim_t const * const gPrims,
	int4 i
) {
#if 0	// boundary condition : flat
	return gPrim_flat;
#endif
#if 1	// boundary condition : fixed (constant zero first-derivatives)
	i.x = clamp(i.x, 0, (int)env->size.x-1);
	i.y = clamp(i.y, 0, (int)env->size.y-1);
	i.z = clamp(i.z, 0, (int)env->size.z-1);
	int const index = indexForInt4(i);
	return gPrims[index];
#endif
#if 0	// boundary condition : stellar schwarzschild
	return calc_gPrim_stellar_Schwarzschild(getX(env, i));
#endif
}

/*
use this for all finite-difference access
TODO
this is producing bad data
is it a matter of argument order?
YES SURE ENOUGH
put the pointer 1st and int4 2nd and it works
put the pointer 2nd and int4 1st and it fails
wait,
STILL THERE
it did work when I made a *copy* and switched the arg order.
but upon modifying the original, it still fails.
ok next test of a working copy:
expand the int arg ...
STILL THERE
honestly I copied this code identiclaly over to another function with only a dif name
the other functin behaved correctly.
this one failed.
STILL THERE
removed the prototype?
STILL THERE
moved the function in the code, next to the working copy?
STILL THERE
renamed
STILL THERE
*/
//inlining the gLL_from_gPrims_at function made the error go away so ....
//what about calling it is so bad ....
// yup this works, whereas the other one fails
real4s4 gLL_from_gPrims_at(
	constant env_t const * const env,
	global gPrim_t const * const gPrims,
	int4 const i
) {
//works
//return real4s4(1,2,3,4,5,6,7,8,9,10);
	if (i.x < 0 || i.y < 0 || i.z < 0 ||
		i.x >= (int)env->size.x || (int)i.y >= env->size.y || (int)i.z >= env->size.z
	) {
		gPrim_t const gPrim = calc_gPrim_boundary(env, gPrims, i);
		real4s4 const gLL = calc_gLL_from_gPrim(gPrim);
		return gLL;
	} else {
		int const index = indexForInt4(i);
		gPrim_t const & gPrim = gPrims[index];
#if 1	
		real4s4 const gLL = calc_gLL_from_gPrim(gPrim);
		return gLL;
#endif	
		//inline
#if 0 //nans		
		real const alphaSq = gPrim.alpha * gPrim.alpha;
		real3 const betaL = gPrim.gammaLL * gPrim.betaU;
		real const betaSq = real3_dot(betaL, gPrim.betaU);
#endif
#if 0	//nans ...
		real const alphaSq = gPrim.alpha * gPrim.alpha;
		real3 const betaL = gPrim.betaU;
		real const betaSq = 
			  gPrim.betaU.s0 * gPrim.betaU.s0
			+ gPrim.betaU.s1 * gPrim.betaU.s1
			+ gPrim.betaU.s2 * gPrim.betaU.s2;
#endif
#if 0	//nans ...
		real const alphaSq = gPrim.alpha * gPrim.alpha;
		real3 const betaL = {};
		real const betaSq = real3_dot(betaL, gPrim.betaU);
#endif
#if 0	//works
		real const alphaSq = 1;
		real3 const betaL = {};
		real const betaSq = real3_dot(betaL, gPrim.betaU);
#endif
#if 0	//works
		real const alphaSq = 1;
		real3 const betaL = {};
		real const betaSq = 0;
#endif

#if 0	//nans
		return real4s4(
			//g_00
			-alphaSq + betaSq,
			//g_0i
			betaL.s0, betaL.s1, betaL.s2,
			//g_ij
			gPrim.gammaLL.s00, gPrim.gammaLL.s01, gPrim.gammaLL.s02,
			gPrim.gammaLL.s11, gPrim.gammaLL.s12, gPrim.gammaLL.s22
		);
#endif
#if 0 // constant values... works
		return real4s4(
			//g_00
			-1,
			//g_0i
			0,0,0,
			//g_ij
			1,0,0,
			1,0,1
		);
#endif	
	}
}

real4s4 gUU_from_gPrims_at(
	constant env_t const * const env,
	global gPrim_t const * const gPrims,
	int4 const i
) {
	if (i.x < 0 || i.y < 0 || i.z < 0 ||
		i.x >= env->size.x || i.y >= env->size.y || i.z >= env->size.z
	) {
		gPrim_t const gPrim = calc_gPrim_boundary(env, gPrims, i);
		return calc_gUU_from_gPrim(gPrim);
	} else {
		int const index = indexForInt4(i);
		return calc_gUU_from_gPrim(gPrims[index]);
	}
}

real4s4 calc_RicciLL(
	constant env_t const * const env,
	int4 const i,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs
) {
	int const index = indexForInt4(i);

	//this Ricci calculation differs from the one in calc_partial_gLL_of_Phis because
	// that one can extract RiemannULLL, which can be used for RicciLL calcs
	// but this one doesn't need RiemannULLL, so we can contract one of the terms in RicciLL's calcs

	real4x4s4 const GammaULL = GammaULLs[index];

	real4s4 const gLL = calc_gLL_from_gPrim(gPrims[index]);
	real4s4 const gUU = calc_gUU_from_gPrim(gPrims[index]);

	//GammaUUL.a.b.c := Γ^ab_c = Γ^a_dc g^db
	real4x4x4 const GammaUUL = real4x4s4_real4s4_mul21(GammaULL, gUU);

	//GammaLLL.a.bc := Γ_abc = g_ad Γ^d_bc
	real4x4s4 const GammaLLL = real4s4_real4x4s4_mul(gLL, GammaULL);

	//Gamma23U.a := Γ^a = Γ^au_u
	real4 const Gamma23U = real4x4x4_tr23(GammaUUL);

	//partial_xU2_of_gLL.ab.cd := ∂_a ∂_b (g_cd)
	// = ∂^2/(∂x^a ∂x^b) (g_cd)
	// = g_cd,ab
<?=solver:finiteDifference2{
	srcType = "4s4",
	resultName = "partial_xU2_of_gLL",
	getValue = function(args) return "gLL_from_gPrims_at(env, gPrims, "..args.i..")" end,
	getBoundary = function(args) return "gLL_from_gPrims_at(env, gPrims, "..args.i..")" end,
}?>

<? if false then -- testing to make sure contraction of Riemann == Ricci
-- ... looks the same as the simplified version below ?>

	//partial_xU2_of_gLL_asym.a.b.c.d := g_ad,bc - g_bd,ac - g_ac,bd + g_bc,ad
	// TODO antisymmetric storage
	//both are T_abcd = -T_bacd = -T_abdc and T_abcd = T_cdab
	real4x4x4x4 partial_xU2_of_gLL_asym;
	for (int a = 0; a < stDim; ++a) {
		for (int b = 0; b < stDim; ++b) {
			for (int c = 0; c < stDim; ++c) {
				for (int d = 0; d < stDim; ++d) {
					partial_xU2_of_gLL_asym.s[a].s[b].s[c].s[d] =
						  partial_xU2_of_gLL.s[sym4[a][d]].s[sym4[b][c]]
						+ partial_xU2_of_gLL.s[sym4[b][c]].s[sym4[a][d]]
						- partial_xU2_of_gLL.s[sym4[b][d]].s[sym4[a][c]]
						- partial_xU2_of_gLL.s[sym4[a][c]].s[sym4[b][d]];
				}
			}
		}
	}

	//GammaSq_asym_LLLL.a.b.c.d := Γ^e_ad Γ_ebc - Γ^e_ac Γ_ebd
	// TODO antisymmetric storage
	real4x4x4x4 GammaSq_asym_LLLL;
	for (int a = 0; a < stDim; ++a) {
		for (int b = 0; b < stDim; ++b) {
			for (int c = 0; c < stDim; ++c) {
				for (int d = 0; d < stDim; ++d) {
					real sum = 0;
					for (int e = 0; e < stDim; ++e) {
						sum +=
							  GammaULL.s[e].s[sym4[a][d]] * GammaLLL.s[e].s[sym4[b][c]]
							- GammaULL.s[e].s[sym4[a][c]] * GammaLLL.s[e].s[sym4[b][d]];
					}
					GammaSq_asym_LLLL.s[a].s[b].s[c].s[d] = sum;
				}
			}
		}
	}

	real4x4x4x4 const gUU_times_partial_xU2_gLL_asym = real4x4x4x4_real4s4_mul_1_1(partial_xU2_of_gLL_asym, gUU);
	real4x4x4x4 const GammaSq_asym_ULLL = real4x4x4x4_real4s4_mul_1_1(GammaSq_asym_LLLL, gUU);

	//RiemannULLL.a.b.cd := R^a_bcd = 1/2 g^ae ((g_ed,cb - g_bd,ce - g_ec,bd + g_bc,de) + g^fg (Γ_fed Γ_gbc - Γ_fec Γ_gbd))
	//TODO antisymmetric storage
	real4x4x4x4 const RiemannULLL = GammaSq_asym_ULLL + .5 * gUU_times_partial_xU2_gLL_asym;

	//RicciLL.ab := R_ab = R^c_acb
	real4s4 const RicciLL = real4x4x4x4_tr13_to_real4s4(RiemannULLL);

<? else  -- testing to make sure contraction of Riemann == Ricci ?>

	/*
	R_abcd = 1/2 (g_ad,cb - g_bd,ca - g_ac,bd + g_bc,da) + g^fg (Γ_fad Γ_gbc - Γ_fac Γ_gbd)
	R^a_bcd = g^ae (1/2 (g_ed,cb - g_bd,ce - g_ec,bd + g_bc,de) + g^fg (Γ_fed Γ_gbc - Γ_fec Γ_gbd))
	RicciLL.ab := R_ab = 1/2 g^uv (g_au,bv + g_bv,au - g_ab,uv - g_uv,ab) + Γ^uv_a Γ_uvb - Γ^uv_v Γ_uab
	*/
	real4s4 RicciLL;
	for (int a = 0; a < stDim; ++a) {
		for (int b = a; b < stDim; ++b) {
			int const ab = sym4[a][b];
			real sum = 0;
			for (int u = 0; u < stDim; ++u) {
				int const au = sym4[a][u];
				for (int v = 0; v < stDim; ++v) {
					int const uv = sym4[u][v];
					int const bv = sym4[b][v];
					sum += .5 * gUU.s[uv] * (
							  partial_xU2_of_gLL.s[au].s[bv]
							+ partial_xU2_of_gLL.s[bv].s[au]
							- partial_xU2_of_gLL.s[ab].s[uv]
							- partial_xU2_of_gLL.s[uv].s[ab]
						)
						+ GammaUUL.s[u].s[v].s[a] * GammaLLL.s[u].s[bv];
				}
				sum -= Gamma23U.s[u] * GammaLLL.s[u].s[ab];
			}
			RicciLL.s[ab] = sum;
		}
	}

<? end  -- testing to make sure contraction of Riemann == Ricci ?>

	return RicciLL;
}

//[1/m^2]
real4s4 calc_EinsteinLL(
	constant env_t const * const env,
	int4 const i,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs
) {
	int const index = indexForInt4(i);

	//gLL.ab := g_ab
	real4s4 gLL = calc_gLL_from_gPrim(gPrims[index]);

	//gUU.ab := g_ab
	real4s4 gUU = calc_gUU_from_gPrim(gPrims[index]);

	//RicciLL.ab := R_ab
	real4s4 const RicciLL = calc_RicciLL(env, i, gPrims, GammaULLs);

	//Gaussian := R = R_ab g^ab
	real const Gaussian = real4s4_dot(RicciLL, gUU);

	//G_uv = R_uv - 1/2 g_uv R
	return RicciLL - (.5 * Gaussian) * gLL;
}

//[1/m^2]
real4s4 calc_8piTLL(
	real4s4 const gLL,
	<?=TPrim_t?> const TPrim
) {
	real4s4 _8piTLL;

<?
if solver.body.useEM then
?>

	/*
	assume the E and B fields are upper 3-vectors
	T_ab = F_au F_b^u - 1/4 g_ab F_uv F^uv
	*/

	real4 const EU = real3_to_real4(TPrim.E);
	real4 const EL = real4s4_real4_mul(gLL, EU);
	real const ESq = real4_dot(EL, EU);

	real4 const BU = real3_to_real4(TPrim.B);
	real4 const BL = real4s4_real4_mul(gLL, BU);
	real const BSq = real4_dot(BL, BU);

	real const sqrt_det_g = sqrt(fabs(real4s4_det(gLL)));
	real3 const SL = real3_real_mul(
		real3_cross(TPrim.E, TPrim.B),
		sqrt_det_g
	);

	_8piTLL.s[sym4[0][0]] += ESq + BSq;
	for (int i = 0; i < sDim; ++i) {
		_8piTLL.s[sym4[0][i+1]] += -2. * SL.s[i];
		for (int j = i; j < sDim; ++j) {
			_8piTLL.s[sym4[i+1][j+1]] += gLL.s[sym4[i+1][j+1]] * (ESq + BSq)
				- 2. * (EL.s[i+1] * EL.s[j+1] + BL.s[i+1] * BL.s[j+1]);
		}
	}
<?
end
if solver.body.useMatter then
	if solver.body.useVel then
?>	//if we're using velocity ...
	//set vU.t = 0 so we only lower by the spatial component of the metric.  right?
	real4 const vU = real3_to_real4(TPrim.v);
	real4 const vL = real4s4_real4_mul(gLL, vU);
	real const vLenSq = real4_dot(vL, vU);	//vU.t = 0 so we'll neglect the vL.t component
	real const W = 1. / sqrt(1. - sqrt(vLenSq));
	real4 const uU = real4(W, W * vU.s1, W * vU.s2, W * vU.s3);
	real4 const uL = real4s4_real4_mul(gLL, uU);
	<? else ?>//otherwise uL = gLL.s0
	real4 const uL = real4(gLL.s00, gLL.s01, gLL.s02, gLL.s03);
<?
	end
?>

	//8 π T_matter_ab = 8 π (u_a u_b (ρ (1 + eInt) + P) + g_ab P)
	//[1/m^2]
	real4s4 const _8piT_matter_LL = 
		(
			(
				real4s4_outer(uL)
				* (TPrim.rho * (1. + TPrim.eInt) + TPrim.P)
			)
			+ gLL * TPrim.P
		) * (8. * M_PI);
	_8piTLL += _8piT_matter_LL;
<? end ?>

	return _8piTLL;
}

// different initial conditions / boundary conditions of gPrims
// this is the only code that uses solver.body

gPrim_t calc_gPrim_flat(real3 const x) {
	return gPrim_t{
		1,
		real3(),
		real3s3_ident,
	};
}

gPrim_t calc_gPrim_stellar_Schwarzschild(real3 const x) {
	gPrim_t gPrim = calc_gPrim_flat(x);

	real const r = real3_len(x);
	real const radius = <?=solver.body.radius?>;
	real const mass = <?=solver.body.mass?>;
	real const density = <?=solver.body.density?>;

	real const matterRadius = real(min(r, radius));
	real const volumeOfMatterRadius = 4./3.*M_PI*matterRadius*matterRadius*matterRadius;
	real const m = density * volumeOfMatterRadius;	// m^3

	/*
	g_ti = beta_i = 0
	g_tt = -alpha^2 + beta^2 = -alpha^2 = -1 + Rs/r <=> alpha = sqrt(1 - Rs/r)
	g_ij = gamma_ij = delta_ij + x^i x^j / r^2 2M/(r - 2M)		<- but x is upper, and you can't lower it without specifying gamma_ij
	 ... which might be why the contravariant spatial metrics of spherical and cartesian look so similar
	*/
	/*
	I'm going by MTW box 23.2 eqn 6 d/dt (proper time) = sqrt(1 - R/r) for r > R
		and ( 3/2 sqrt(1 - 2 M / R) - 1/2 sqrt(1 - 2 M r^2 / R^3) ) for r < R
		for M = total mass
		and R = planet radius
	*/
	gPrim.alpha = r > radius
		? sqrt(1 - 2*mass/r)
		: (1.5 * sqrt(1 - 2*mass/radius) - .5 * sqrt(1 - 2*mass*r*r/(radius*radius*radius)));

	for (int i = 0; i < sDim; ++i) {
		gPrim.betaU.s[i] = 0;
		for (int j = i; j < sDim; ++j) {
			gPrim.gammaLL.s[sym3[i][j]] = (i == j ? 1. : 0.) + x.s[i]/r * x.s[j]/r * 2*m/(r - 2*m);
		}
	}

	/*
	dr^2's coefficient
	spherical: 1/(1 - 2M/r) = 1/((r - 2M)/r) = r/(r - 2M)
	spherical contravariant: 1 - 2M/r
	cartesian contravariant: delta_ij - x/r y/r 2M/r
	hmm, contravariant terms of cartesian vs spherical look more similar than covariant terms do

	in the OV metric, dr^2's coefficient is exp(2 Lambda) = 1/(1 - 2 m(r) / r) where m(r) is the enclosing mass
	so the contravariant coefficient would be exp(-2 Lambda) = 1 - 2 m(r) / r
	I'm going to do the lazy thing and guess this converts to delta^ij - 2 m(r) x^i x^j / r^3
	*/

#if 0	//rotating about a distance
	/*
	now if we are going to rotate this
	at a distance of L and at an angular frequency of omega
	(not considering relativistic Thomas precession just yet)

	this might be a mess, but I'm (1) calculating the change in time as if I were in a frame rotating by L exp(i omega t)
	then (2) re-centering the frame at L exp(i omega t) ... so I can use the original coordinate system
	*/
	real const dr_alpha = r > radius
		? (mass / (r * r * sqrt(1. - 2. * mass / r)))
		: (mass * r / (radius * radius * radius * sqrt(1. - 2. * mass * r * r / (radius * radius * radius))));
	real const dr_m = r > radius ? 0 : (4. * M_PI * r * r * density);
	MetricPrims & dt_metricPrims = dt_metricPrimGrid(index);
	real const L = 149.6e+9;	//distance from earth to sun, in m
	//real omega = 0; //no rotation
	//real omega = 2. * M_PI / (60. * 60. * 24. * 365.25) / c;	//one revolution per year in m^-1
	//real omega = 1;	//angular velocity of the speed of light
	real const omega = c;	//I'm trying to find a difference ...
	real const t = 0;	//where the position should be.  t=0 means the body is moved by [L, 0], and its derivatives are along [0, L omega]
	Vector<real,2> dt_xHat(L * omega * sin(omega * t), -L * omega * cos(omega * t));
	dt_metricPrims.alpha = dr_alpha * (xi(0)/r * dt_xHat(0) + xi(1)/r * dt_xHat(1));
	for (int i = 0; i < sDim; ++i) {
		dt_metricPrims.betaU(i) = 0;
	}
	for (int i = 0; i < sDim; ++i) {
		for (int j = 0; j < sDim; ++j) {
			real sum = 0;
			for (int k = 0; k < 2; ++k) {
				//gamma_ij = f/g
				//so d/dxHat^k gamma_ij =
				real dxHat_k_of_gamma_ij =
				// f' / g
				(
					((i==k)*xi(j) + xi(i)*(j==k)) * 2.*m + xi(i)*xi(j) * 2.*dr_m * xi(k)/r
				) / (r * r * (r - 2 * m))
				// - f g' / g^2
				- (xi(i) * xi(j) * 2 * m) * ( (xi(k) - 2 * dr_m * xi(k)) * r + 2 * xi(k) * (r - 2 * m) )
				/ (r * r * r * r * (r - 2 * m) * (r - 2 * m));
				sum += dxHat_k_of_gamma_ij * dt_xHat(k);
			}
			dt_metricPrims.gammaLL(i,j) = sum;
		}
	}
#endif

#if 0	//work that beta
	/*
	so if we can get the gamma^ij beta_j,t components to equal the Gamma^t_tt components ...
	 voila, gravity goes away.
	I'm approximating this as beta^i_,t ... but it really is beta^j_,t gamma_ij + beta^j gamma_ij,t
	 ... which is the same as what I've got, but I'm setting gamma_ij,t to zero
	*/
	//expanding ...
	MetricPrims& dt_metricPrims = dt_metricPrimGrid(index);
	TensorLsub betaL;
	for (int i = 0; i < sDim; ++i) {
		//negate all gravity by throttling the change in space/time coupling of the metric
		real dm_dr = 0;
		betaL(i) = -(2*m * (r - 2*m) + 2 * dm_dr * r * (2*m - r)) / (2 * r * r * r) * xi(i)/r;
	}
	TensorSUsub gammaUU = inverse(metricPrims.gammaLL);
	for (int i = 0; i < sDim; ++i) {
		real sum = 0;
		for (int j = 0; j < sDim; ++j) {
			sum += gammaUU(i,j) * betaL(j);
		}
		dt_metricPrims.betaU(i) = sum;
	}
#endif

	return gPrim;
}

gPrim_t calc_gPrim_stellar_Kerr_Newman(real3 const x) {
	gPrim_t gPrim = calc_gPrim_flat(x);

	real const radius = <?=solver.body.radius?>;
	real const mass = <?=solver.body.mass?>;
	real const density = <?=solver.body.density?>;

	real const angularVelocity = 2. * M_PI / (60. * 60. * 24.) / c;	//angular velocity, in m^-1
	real const inertia = 2. / 5. * mass * radius * radius;	//moment of inertia about a sphere, in m^3
	real const angularMomentum = inertia * angularVelocity;	//angular momentum in m^2
	real const a = angularMomentum / mass;	//m

	//real r is the solution of (x*x + y*y) / (r*r + a*a) + z*z / (r*r) = 1
	// r^4 - (x^2 + y^2 + z^2 - a^2) r^2 - a^2 z^2 = 0
	real const RSq_minus_aSq = real3_lenSq(x) - a*a;
	//so we have two solutions ... which do we use?
	//from gnuplot it looks like the two of these are the same ...
	real const r = sqrt((RSq_minus_aSq + sqrt(RSq_minus_aSq * RSq_minus_aSq + 4.*a*a*x.z*x.z)) / 2.);	//use the positive root

	//should I use the Kerr-Schild 'r' coordinate?
	//well, if 'm' is the mass enclosed within the coordinate
	// and that determines 'a', the angular momentum per mass within the coordinate (should it?)
	// then we would have a circular definition
	//real R = real3_len(x);
	real const matterRadius = min(r, radius);
	real const volumeOfMatterRadius = 4./3.*M_PI*matterRadius*matterRadius*matterRadius;
	real const m = density * volumeOfMatterRadius;	// m^3

	real const Q = 0;	//charge
	real const H = (r*m - Q*Q/2.)/(r*r + a*a*x.z*x.z/(r*r));

	//3.4.33 through 3.4.35 of Alcubierre "Introduction to 3+1 Numerical Relativity"

	/*TODO fix this for the metric within the star
	 in other news, this is an unsolved problem!
	https://arxiv.org/pdf/1503.02172.pdf section 3.11
	https://arxiv.org/pdf/1410.2130.pdf section 4.2 last paragraph
	*/
	//metricPrims.alpha = 1./sqrt(1. + 2*H);
	gPrim.alpha = sqrt(1. - 2*H/(1+2*H) );

	real3 const l = real3(
		(r*x.x + a*x.y)/(r*r + a*a),
		(r*x.y - a*x.x)/(r*r + a*a),
		x.z/r 
	);
<?
for i=0,sDim-1 do
?>	gPrim.betaU.s<?=i?> = 2. * H * l.s<?=i?> / (1. + 2. * H);
<?
	for j=i,sDim-1 do
?>	gPrim.gammaLL.s<?=i..j?> = <?if i==j then?>1. + <?end?>2. * H * l.s<?=i?> * l.s<?=j?>;
<?	end
end
?>
	return gPrim;
}

real4s4 calc_gLL_from_gPrim(
	gPrim_t const & gPrim
) {
#if 0	//works
return real4s4(1,2,3,4,5,6,7,8,9,10);
#endif

	real const alpha = gPrim.alpha;
	real3 const & betaU = gPrim.betaU;
	real3s3 const & gammaLL = gPrim.gammaLL;

	real const alphaSq = alpha * alpha;
	real3 const betaL = gammaLL * betaU;
	real const betaSq = real3_dot(betaL, betaU);

#if 1	//works
	return real4s4(
		-alphaSq,
		0,
		1,
		2,
		0,
		1,
		2,
		11,
		12,
		22
	);
#endif
#if 0 //works
	return real4s4(
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10
	);
#endif
#if 0	//nans
	real4s4 gLL;
	gLL.s00 = -alphaSq + betaSq;
	for (int i = 0; i < sDim; ++i) {
		gLL.s[sym4[0][i+1]] = betaL.s[i];
		for (int j = i; j < sDim; ++j) {
			gLL.s[sym4[i+1][j+1]] = gammaLL.s[sym3[i][j]];
		}
	}
	return gLL;
#endif
#if 0	//nans
	return real4s4(
		-alphaSq + betaSq,
		betaL.s0,
		betaL.s1,
		betaL.s2,
		gammaLL.s00,
		gammaLL.s01,
		gammaLL.s02,
		gammaLL.s11,
		gammaLL.s12,
		gammaLL.s22
	);
#endif
}

real4s4 calc_gUU_from_gPrim(
	gPrim_t const & gPrim
) {
	real const alpha = gPrim.alpha;
	real const invAlphaSq = 1. / (alpha * alpha);
	real3 const & betaU = gPrim.betaU;

	real3s3 const gammaLL = gPrim.gammaLL;
	real const det_gammaLL = real3s3_det(gammaLL);
	real3s3 const gammaUU = real3s3_inv(gammaLL, det_gammaLL);

#if 0
	real4s4 gUU;
	gUU.s00 = -invAlphaSq;
	for (int i = 0; i < sDim; ++i) {
		gUU.s[sym4[0][i+1]] = betaU.s[i] * invAlphaSq;
		for (int j = i; j < sDim; ++j) {
			gUU.s[sym4[i+1][j+1]] = gammaUU.s[sym3[i][j]] - betaU.s[i] * betaU.s[j] * invAlphaSq;
		}
	}
	return gUU;
#endif
#if 1
	return real4s4(
		-invAlphaSq,
		betaU.s0 * invAlphaSq,
		betaU.s1 * invAlphaSq,
		betaU.s2 * invAlphaSq,
		gammaUU.s00 - betaU.s0 * betaU.s0 * invAlphaSq,
		gammaUU.s01 - betaU.s0 * betaU.s1 * invAlphaSq,
		gammaUU.s02 - betaU.s0 * betaU.s2 * invAlphaSq,
		gammaUU.s11 - betaU.s1 * betaU.s1 * invAlphaSq,
		gammaUU.s12 - betaU.s1 * betaU.s2 * invAlphaSq,
		gammaUU.s22 - betaU.s2 * betaU.s2 * invAlphaSq
	);
#endif
}

// gradient descent , but I'm moving everything into this file so the display shader can see it...

real4s4x4s4 calc_partial_gLL_of_8piTLL(
	<?=TPrim_t?> const & TPrim,
	real4s4 const & gLL,
	real4s4 const & gUU
) {
	real4s4x4s4 partial_gLL_of_8piTLL;
<?
if solver.body.useEM then ?>
	real4 const EU = real3_to_real4(TPrim.E);
	real4 const EL = gLL * EU;
	real const ESq = real4_dot(EL, EU);

	real4 const BU = real3_to_real4(TPrim.B);
	real4 const BL = gLL * BU;
	real const BSq = real4_dot(BL, BU);

	real const sqrt_det_g = sqrt(fabs(real4s4_det(gLL)));
	real3 const SL = real3_cross(TPrim.E, TPrim.B) * sqrt_det_g;

	for (int e = 0; e < stDim; ++e) {
		for (int f = e; f < stDim; ++f) {
			int const ef = sym4[e][f];
			if (e > 0 && f > 0) {
				partial_gLL_of_8piTLL.s[ef].s[sym4[0][0]] += TPrim.E.s[e-1] * TPrim.E.s[f-1] + TPrim.B.s[e-1] * TPrim.B.s[f-1];
			}
			for (int i = 0; i < sDim; ++i) {
				partial_gLL_of_8piTLL.s[ef].s[sym4[0][i+1]] -= SL.s[i] * gUU.s[ef];
				for (int j = i; j < sDim; ++j) {

					real sum = 0;
					if (e == i+1 && f == j+1) sum += ESq + BSq;

					if (e > 0 && f > 0) {
						sum += gLL.s[sym4[i+1][j+1]] * (TPrim.E.s[e-1] * TPrim.E.s[f-1] + TPrim.B.s[e-1] * TPrim.B.s[f-1]);
					}
					if (e == i+1) {
						sum -= 2. * (EU.s[f] * EL.s[j+1] + BU.s[f] * BL.s[j+1]);
					}
					if (e == j+1) {
						sum -= 2. * (EU.s[f] * EL.s[i+1] + BU.s[f] * BL.s[i+1]);
					}

					partial_gLL_of_8piTLL.s[ef].s[sym4[i+1][j+1]] += sum;
				}
			}
		}
	}
<?
end

if solver.body.useMatter then
	if solver.body.useVel then -- if we're using velocity ...
?>
	//set vU.t = 0 so we only lower by the spatial component of the metric.  right?
	real4 const vU = real3_to_real4(TPrim.v);
	real4 const vL = gLL * vU;
	real const vLenSq = real4_dot(vL, vU);	//vU.t = 0 so we'll neglect the vL.t component
	real const W = 1. / sqrt(1. - sqrt(vLenSq));
	real4 const uU = real4(W, W * vU.s1, W * vU.s2, W * vU.s3);
	real4 const uL = gLL * uU;
<?
	else -- otherwise uL = gLL.s0
?>
	real4 const uL = real4(gLL.s00, gLL.s01, gLL.s02, gLL.s03);
<?
	end
?>
	for (int e = 0; e < stDim; ++e) {
		for (int f = e; f < stDim; ++f) {
			int const ef = sym4[e][f];
			for (int a = 0; a < stDim; ++a) {
				for (int b = a; b < stDim; ++b) {
					int const ab = sym4[a][b];
					real sum = 0;
					if (e == a) sum += uL.s[b];
					if (e == b) sum += uL.s[a];
					sum *= uL.s[f] * (TPrim.rho * (1. + TPrim.eInt) + TPrim.P);
					if (ef == ab) sum += TPrim.P;
					partial_gLL_of_8piTLL.s[ef].s[ab] += sum;
				}
			}
		}
	}
<?
end
?>
	return (8. * M_PI) * partial_gLL_of_8piTLL;
}

real4s4 EFE_LL_minus_half_trace_at(
	constant env_t const * const env,
	global gPrim_t const * const gPrims,
	global real4s4 const * const EFEs,
	int4 const i
) {
	if (i.x < 0 || i.y < 0 || i.z < 0 ||
		i.x >= env->size.x || i.y >= env->size.y || i.z >= env->size.z
	) {
		return real4s4();	//TODO ... consider boundary conditions
	}

	int const index = indexForInt4(i);
	real4s4 const gLL = calc_gLL_from_gPrim(gPrims[index]);	// g_ab
	real4s4 const gUU = calc_gUU_from_gPrim(gPrims[index]);	// g^ab
	real4s4 const EFE = EFEs[index];	// G_ab - 8 π T_ab

	//lower times lower, but used for minimizing frobenius norm of EFE_ab
	// Sum_ab (G_ab - 8 π T_ab) g_ab
	real const EFE_LL_dot_gLL = real4s4_dot(EFE, gLL);

	// common term in the gradient descent:
	// (G_uv - 8 π T_uv) - 1/2 (G_ab - 8 π T_ab) g_ab g^uv
	return EFE - (.5 * EFE_LL_dot_gLL) * gUU;
}

//GammaULL.a.b.c := Γ^a_bc
real4x4s4 GammaULL_at(
	constant env_t const * const env,
	int4 const i,
	global real4x4s4 const * const GammaULLs
) {
	if (i.x < 0 || i.y < 0 || i.z < 0 ||
		i.x >= env->size.x || i.y >= env->size.y || i.z >= env->size.z
	) {
		return real4x4s4();
	}

	int const index = indexForInt4(i);
	return GammaULLs[index];
}

//GammaUUL.a.b.c := Γ^ab_c = Γ^a_dc g^db
real4x4x4 GammaUUL_at(
	constant env_t const * const env,
	int4 const i,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs
) {
	if (i.x < 0 || i.y < 0 || i.z < 0 ||
		i.x >= env->size.x || i.y >= env->size.y || i.z >= env->size.z
	) {
		return real4x4x4();
	}
	int const index = indexForInt4(i);

	real4s4 const gUU = calc_gUU_from_gPrim(gPrims[index]);

	return real4x4s4_real4s4_mul21(GammaULLs[index], gUU);
}
real4s4 calc_partial_gLL_of_Phi(
	constant env_t const * const env,
	global <?=TPrim_t?> const * const TPrims,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs,
	global real4s4 const * const EFEs,
	int4 const i
) {
	int const index = indexForInt4(i);

	real4s4 const gLL = calc_gLL_from_gPrim(gPrims[index]);
	real4s4 const gUU = calc_gUU_from_gPrim(gPrims[index]);
	real4x4s4 const GammaULL = GammaULLs[index];

	//partial_xU2_of_gLL.cd.ab := g_ab,cd
<?=solver:finiteDifference2{
	srcType = "4s4",
	resultName = "partial_xU2_of_gLL",
	getValue = function(args) return "gLL_from_gPrims_at(env, gPrims, "..args.i..")" end,
	getBoundary = function(args) return "gLL_from_gPrims_at(env, gPrims, "..args.i..")" end,
}?>

	//TODO or store this?
	//GammaLLL.a.bc := Γ_abc = g_au Γ^u_bc
	real4x4s4 const GammaLLL = real4s4_real4x4s4_mul(gLL, GammaULL);

	//partial_xU2_of_gLL_asym.a.b.c.d := g_ad,bc - g_bd,ac - g_ac,bd + g_bc,ad
	// TODO antisymmetric storage
	//both are T_abcd = -T_bacd = -T_abdc and T_abcd = T_cdab
	real4x4x4x4 partial_xU2_of_gLL_asym;
	for (int a = 0; a < stDim; ++a) {
		for (int b = 0; b < stDim; ++b) {
			for (int c = 0; c < stDim; ++c) {
				for (int d = 0; d < stDim; ++d) {
					partial_xU2_of_gLL_asym.s[a].s[b].s[c].s[d] =
						partial_xU2_of_gLL.s[sym4[a][d]].s[sym4[b][c]]
						+ partial_xU2_of_gLL.s[sym4[b][c]].s[sym4[a][d]]
						- partial_xU2_of_gLL.s[sym4[b][d]].s[sym4[a][c]]
						- partial_xU2_of_gLL.s[sym4[a][c]].s[sym4[b][d]];
				}
			}
		}
	}

	//GammaSq_asym_LLLL.a.b.c.d := Γ^e_ad Γ_ebc - Γ^e_ac Γ_ebd
	// not the same as the popular 2 Γ^a_e[c Γ^e_d]b used for Riemann with 2 ∂/dx^[c Γ^a_d]b
	// instead this is the one used with 2 g_[a[b,c]d]
	// TODO antisymmetric storage
	real4x4x4x4 GammaSq_asym_LLLL;
	for (int a = 0; a < stDim; ++a) {
		for (int b = 0; b < stDim; ++b) {
			for (int c = 0; c < stDim; ++c) {
				for (int d = 0; d < stDim; ++d) {
					real sum = 0.;
					for (int e = 0; e < stDim; ++e) {
						sum += GammaULL.s[e].s[sym4[a][d]] * GammaLLL.s[e].s[sym4[b][c]]
							- GammaULL.s[e].s[sym4[a][c]] * GammaLLL.s[e].s[sym4[b][d]];
					}
					GammaSq_asym_LLLL.s[a].s[b].s[c].s[d] = sum;
				}
			}
		}
	}

	// linear transform, not necessarily tensoral (since neither is anyways)
	real4x4x4x4 const gUU_times_partial_xU2_gLL_asym = real4x4x4x4_real4s4_mul_1_1(partial_xU2_of_gLL_asym, gUU);
	real4x4x4x4 const GammaSq_asym_ULLL = real4x4x4x4_real4s4_mul_1_1(GammaSq_asym_LLLL, gUU);

	//RiemannLLLL.a.b.c.d := R_abcd
	//= 1/2 (g_ad,bc - g_bd,ac - g_ac,bd + g_bc,ad) + g^fg (Γ_fad Γ_gbc - Γ_fac Γ_gbd)
	//= 1/2 (g_ad,bc - g_bd,ac - g_ac,bd + g_bc,ad) + Γ^e_ad Γ_ebc - Γ^e_ac Γ_ebd
	// TODO antisymmetric storage
	// but this requires inserting -1's for reading/writing ...

	//RiemannULLL.a.b.c.d := R^a_bcd = 1/2 g^ae ((g_ed,cb - g_bd,ce - g_ec,bd + g_bc,de) + g^fg (Γ_fed Γ_gbc - Γ_fec Γ_gbd))
	//TODO antisymmetric storage
	real4x4x4x4 const RiemannULLL = GammaSq_asym_ULLL + .5 * gUU_times_partial_xU2_gLL_asym;

	//RiemannULUL.a.b.c.d = R^a_b^c_d = R^a_bud g^uc
	real4x4x4x4 const RiemannULUL = real4x4x4x4_real4s4_mul_3_1(RiemannULLL, gUU);

	//RicciLL.ab := R_ab = R^c_acb
	real4s4 const RicciLL = real4x4x4x4_tr13_to_real4s4(RiemannULLL);

	//RicciUL.a.b := R^a_b = g^ac R_cb
	real4x4 const RicciUL = gUU * RicciLL;

	//RicciUU.ab := R^ab = R^a_c g^cb
	real4s4 const RicciUU = real4x4_real4s4_to_real4s4_mul(RicciUL, gUU);

	//Gaussian := R = R^a_a
	real const Gaussian = real4x4_tr(RicciUL);

	real4s4x4s4 const partial_gLL_of_8piTLL = calc_partial_gLL_of_8piTLL(TPrims[index], gLL, gUU);

	real4s4 const EFE = EFEs[index];	// G_ab - 8 π T_ab

	//lower times lower, but used for minimizing frobenius norm of EFE_ab
	// Sum_ab (G_ab - 8 π T_ab) g_ab
	real const EFE_LL_dot_gLL = real4s4_dot(EFE, gLL);

	// common term in the gradient descent:
	// (G_uv - 8 π T_uv) - 1/2 (G_ab - 8 π T_ab) g_ab g^uv
	real4s4 EFE_LL_minus_half_trace = EFE - (.5 * EFE_LL_dot_gLL) * gUU;

	//GammaUUL.a.b.c := Γ^ab_c = Γ^a_dc g^db
	real4x4x4 const GammaUUL = real4x4s4_real4s4_mul21(GammaULL, gUU);

	//Gamma23U.a := Γ^a = Γ^au_u
	real4 const Gamma23U = real4x4x4_tr23(GammaUUL);

	// GammaSq_tr_2_2.pq.uv := Γ^pc_v Γ^q_cu - Γ^pc_c Γ^q_uv
	// symmetries?
	real4x4x4x4 GammaSq_tr_2_2;
	for (int p = 0; p < stDim; ++p) {
		for (int q = 0; q < stDim; ++q) {
			for (int u = 0; u < stDim; ++u) {
				for (int v = 0; v < stDim; ++v) {
					real sum = - Gamma23U.s[p] * GammaULL.s[q].s[sym4[u][v]];
					for (int c = 0; c < stDim; ++c) {
						sum += GammaUUL.s[p].s[c].s[v] * GammaULL.s[q].s[sym4[c][u]];
					}
					GammaSq_tr_2_2.s[p].s[q].s[u].s[v] = sum;
				}
			}
		}
	}

	//partial_gLL_of_Phi.pq := ∂Φ/∂g_pq
	real4s4 partial_gLL_of_Phi;
	// first calculate non-partial non ∂/∂g_pq terms:
	for (int p = 0; p < stDim; ++p) {
		for (int q = p; q < stDim; ++q) {
			int const pq = sym4[p][q];
			real sum = 0;
#if 1
			// -(G_pq - 8 π T_pq) R
			sum -= EFE.s[pq] * Gaussian;
#endif
#if 1
			// + Sum_ab EFE_ab 1/2 g_ab R^pq
			sum += EFE_LL_dot_gLL * .5 * RicciUU.s[pq];
#endif
#if 1
			for (int a = 0; a < stDim; ++a) {
				for (int b = 0; b < stDim; ++b) {
					int const ab = sym4[a][b];
					// - Sum_ab EFE_ab 8 π dT_ab/dg_pq
					sum -= EFE.s[ab] * partial_gLL_of_8piTLL.s[pq].s[ab];
				}
			}
#endif
#if 1
			for (int u = 0; u < stDim; ++u) {
				for (int v = 0; v < stDim; ++v) {
					int const uv = sym4[u][v];
					sum -= EFE_LL_minus_half_trace.s[uv] * (
					// - (EFE_uv - 1/2 EFE_ab g_ab g^uv) R^p_u^q_v
						RiemannULUL.s[p].s[u].s[q].s[v]
					// - (EFE_uv - 1/2 EFE_ab g_ab g^uv) (Γ^pc_v Γ^q_cu - Γ^pc_c Γ^q_uv)
						+ GammaSq_tr_2_2.s[p].s[q].s[u].s[v]
					);
				}
			}
#endif
#if 0
			// next calculate first-derivatives of ∂/∂g_pq terms:
			for (int dim = 0; dim < sDim; ++dim) {
				for (int offset = -<?=solver.diffOrder/2?>; offset <= <?=solver.diffOrder/2?>; ++offset) {
					if (offset == 0) continue;
					int4 const iofs = i + int4_dir(dim, offset);
					// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) g^cd (δ^f_c δ^g_v Γ^e_ud + δ^f_u δ^g_d Γ^e_cv - δ^f_c δ^g_d Γ^e_uv - δ6f_u δ^g_v Γ^e_cd) 1/2 (∂/∂g_pq(x') (D_g[g_ef] + D_f[g_eg] - D_e[g_fg]) = δ^p_e δ^q_f d1coeff_g + δ^p_e δ^q_g d1coeff_f - δ^p_f δ^q_g d1coeff_e)
					// ... expanding all 12 terms with symmath and simplifying...
					/*
					asking symmath to simplify this for me:
					let H^uv = (G_ab - 8 π T_ab) (δ^u_a δ^v_b - 1/2 g_ab g^uv) = EFE_uv - 1/2 EFE_ab g_ab g^uv
						> delta = Tensor.deltaSymbol()
						> g = Tensor.metricSymbol()
						> (H'^uv' * g'^cd' * (delta'^f_c' * delta'^g_v' * Gamma'^e_ud' + delta'^f_u' * delta'^g_d' * Gamma'^e_cv' - delta'^f_c' * delta'^g_d' * Gamma'^e_uv' - delta'^f_u' * delta'^g_v' * Gamma'^e_cd') * (delta'^p_e' * delta'^q_f' * phi'_g' + delta'^p_e' * delta'^q_g' * phi'_f' - delta'^p_f' * delta'^q_g' * phi'_e'))
							:simplifyMetrics()
							:symmetrizeIndexes(H, {1,2})()
							:symmetrizeIndexes(Gamma, {2,3})()
							:symmetrizeIndexes(g, {1,2})()
							:tidyIndexes()()
							:symmetrizeIndexes(H, {1,2})()
							:favorTensorVariance(phi'_a')()
					...gives...
							  φ_a * H^pq * Γ^ab_b
						-     φ_a * H^pb * Γ^aq_b
						-     φ_a * H^bq * Γ^ap_b
						+     φ_a * H^bc * Γ^a_bc * g^pq
						- 2 * φ_a * H^aq * Γ^pb_b
						+ 2 * φ_a * H^ab * Γ^pq_b
						+ 2 * φ_a * H^bq * Γ^pa_b
						- 2 * φ_a * H^bc * Γ^p_cb * g^aq
					*/
					int const a = dim+1;
					for (int b = 0; b < stDim; ++b) {
						sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[pq] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[a].s[b].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[p][b]] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[a].s[q].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[b][q]] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[a].s[p].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						for (int c = 0; c < stDim; ++c) {
							sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[b][c]] * GammaULL_at(env, iofs, GammaULLs).s[a].s[sym4[b][c]] * gUU_from_gPrims_at(env, gPrims, iofs).s[pq] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						}
						sum -= EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[a][q]] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[p].s[b].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						sum += EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[a][b]] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[p].s[q].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						sum += EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[b][q]] * GammaUUL_at(env, iofs, gPrims, GammaULLs).s[p].s[a].s[b] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						for (int c = 0; c < stDim; ++c) {
							sum -= EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[b][c]] * GammaULL_at(env, iofs, GammaULLs).s[p].s[sym4[c][b]] * gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[a][q]] * d1coeff_for_offset(offset) * env->invdx.s[dim];
						}
					}
				}
			}
#endif
#if 0
			// next calculate second-derivatives of ∂/∂g_pq terms:
			for (int dim1 = 0; dim1 < sDim; ++dim1) {
				for (int dim2 = 0; dim2 < sDim; ++dim2) {
					if (dim1 == dim2) {
						for (int offset = -<?=solver.diffOrder/2?>; offset <= <?=solver.diffOrder/2?>; ++offset) {
							int4 const iofs = i + int4_dir(dim1, offset);
							{
								// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_ud[g_cv] = δ^p_c δ^q_v D^2 d2coeff_ud)
								// = + (EFE_uq - 1/2 EFE_ab g_ab g^uq) 1/2 g^pd (d2coeff_ud) |x'=x + dx^u=dx^d
								int const u = dim1+1;
								int const d = u;
								sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[u][q]]
									* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[p][d]]
									* (d2coeffs[abs(offset)] * env->invdx.s[dim1]);
							}{
								// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_cv[g_ud] = δ^p_u δ^q_d D^2 d2coeff_cv)
								// = + (EFE_pv - 1/2 EFE_ab g_ab g^pv) 1/2 g^cq (d2coeff_cv) |x'=x + dx^v=dx^c
								int const v = dim1+1;
								int const c = v;
								sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[p][v]]
									* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[c][q]]
									* (d2coeffs[abs(offset)] * env->invdx.s[dim1]);
							}{
								// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_cd[g_uv] = δ^p_u δ^q_v D^2 d2coeff_cd)
								// = + (EFE_pq - 1/2 EFE_ab g_ab g^pq) 1/2 g^cd (d2coeff_cd) |x'=x + dx^c=dx^d
								int const c = dim1+1;
								int const d = c;
								sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[pq]
									* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[c][d]]
									* (d2coeffs[abs(offset)] * env->invdx.s[dim1]);
							}{
								// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_uv[g_cd] = δ^p_c δ^q_d D^2 d2coeff_uv)
								// = + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^pq (d2coeff_uv) |x'=x + dx^u=dx^v
								int const u = dim1+1;
								int const v = u;
								sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[u][v]]
									* gUU_from_gPrims_at(env, gPrims, iofs).s[pq]
									* (d2coeffs[abs(offset)] * env->invdx.s[dim1]);
							}
						}
					} else {
						for (int offset1 = -<?=solver.diffOrder/2?>; offset1 <= <?=solver.diffOrder/2?>; ++offset1) {
							if (offset1 == 0) continue;
							for (int offset2 = -<?=solver.diffOrder/2?>; offset2 <= <?=solver.diffOrder/2?>; ++offset2) {
								if (offset2 == 0) continue;
								int4 const iofs = i + int4_dir(dim1, offset1) + int4_dir(dim2, offset2);
								{
									// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_ud[g_cv] = δ^p_c δ^q_v D^2 d1coeff_u d1coeff_d)
									// = + (EFE_uq - 1/2 EFE_ab g_ab g^uq) 1/2 g^pd (d1coeff_u d1coeff_d) |x'=x + dx^u + dx^d
									int const u = dim1+1;
									int const d = dim2+1;
									int const offset_u = offset1;
									int const offset_d = offset2;
									sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[u][q]]
										* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[p][d]]
										* (d1coeff_for_offset(offset_u) * d1coeff_for_offset(offset_d) * env->invdx.s[dim1] * env->invdx.s[dim2]);
								}{
									// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_cv[g_ud] = δ^p_u δ^q_d D^2 d1coeff_c d1coeff_v)
									// = + (EFE_pv - 1/2 EFE_ab g_ab g^pv) 1/2 g^cq (d1coeff_c d1coeff_v) |x'=x + dx^v + dx^c
									int const v = dim1+1;
									int const c = dim2+1;
									int const offset_v = offset1;
									int const offset_c = offset2;
									sum += .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[p][v]]
										* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[c][q]]
										* (d1coeff_for_offset(offset_v) * d1coeff_for_offset(offset_c) * env->invdx.s[dim1] * env->invdx.s[dim2]);
								}{
									// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_cd[g_uv] = δ^p_u δ^q_v D^2 d1coeff_c d1coeff_d)
									// = + (EFE_pq - 1/2 EFE_ab g_ab g^pq) 1/2 g^cd (d1coeff_c d1coeff_d) |x'=x + dx^c + dx^d
									int const c = dim1+1;
									int const d = dim2+1;
									int const offset_c = offset1;
									int const offset_d = offset2;
									sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[pq]
										* gUU_from_gPrims_at(env, gPrims, iofs).s[sym4[c][d]]
										* (d1coeff_for_offset(offset_c) * d1coeff_for_offset(offset_d) * env->invdx.s[dim1] * env->invdx.s[dim2]);
								}{
									// + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^cd (∂/∂g_pq(x') D^2_uv[g_cd] = δ^p_c δ^q_d D^2 d1coeff_u d1coeff_v)
									// = + (EFE_uv - 1/2 EFE_ab g_ab g^uv) 1/2 g^pq (d1coeff_u d1coeff_v) |x'=x + dx^u + dx^v
									int const u = dim1+1;
									int const v = dim2+1;
									int const offset_u = offset1;
									int const offset_v = offset2;
									sum -= .5 * EFE_LL_minus_half_trace_at(env, gPrims, EFEs, iofs).s[sym4[u][v]]
										* gUU_from_gPrims_at(env, gPrims, iofs).s[pq]
										* (d1coeff_for_offset(offset_u) * d1coeff_for_offset(offset_v) * env->invdx.s[dim1] * env->invdx.s[dim2]);
								}
							}
						}
					}
				}
			}
#endif
			partial_gLL_of_Phi.s[pq] = sum;
		}
	}

	return partial_gLL_of_Phi;
}

gPrim_t calc_partial_gPrim_of_Phi(
	constant env_t const * const env,
	global <?=TPrim_t?> const * const TPrims,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs,
	global real4s4 const * const EFEs,
	int4 const i
) {
	int const index = indexForInt4(i);

	real4s4 const partial_gLL_of_Phi = calc_partial_gLL_of_Phi(env, TPrims, gPrims, GammaULLs, EFEs, i);

	gPrim_t const gPrim = gPrims[index];
	real3s3 const gammaLL = gPrim.gammaLL;
	real3 const betaU = gPrim.betaU;
	real3 const betaL = gammaLL * betaU;

	gPrim_t partial_gPrim_of_Phi;

	partial_gPrim_of_Phi.alpha = -2. * gPrim.alpha * partial_gLL_of_Phi.s00;
	for (int m = 0; m < sDim; ++m) {
		partial_gPrim_of_Phi.betaU.s[m] = 2. * partial_gLL_of_Phi.s00 * betaL.s[m];
		for (int n = 0; n < sDim; ++n) {
			partial_gPrim_of_Phi.betaU.s[m] += partial_gLL_of_Phi.s[sym4[0][n+1]] * gammaLL.s[sym3[n][m]];
		}
	}
	for (int m = 0; m < sDim; ++m) {
		for (int n = m; n < sDim; ++n) {
			int const mn = sym3[m][n];
			partial_gPrim_of_Phi.gammaLL.s[mn] =
				partial_gLL_of_Phi.s[sym4[m+1][n+1]]
				+ betaU.s[m] * (
					  partial_gLL_of_Phi.s[sym4[0][0]] * betaU.s[n]
					+ 2. * partial_gLL_of_Phi.s[sym4[0][n+1]]
				);
		}
	}

	return partial_gPrim_of_Phi;
}
