// here is the code used for updating weights based on the EFE

#include "autogen.h"
#include "math.hpp"
#include "efe.h"

#ifdef CLCPU_ENABLED
#define constant
#define global
#define local
#endif

kernel void calc_partial_gPrim_of_Phis_kernel(
	constant env_t const * const env,
	global gPrim_t * const partial_gPrim_of_Phis,
	global <?=TPrim_t?> const * const TPrims,
	global gPrim_t const * const gPrims,
	global real4x4s4 const * const GammaULLs,
	global real4s4 const * const EFEs
) {
	initKernel();

	partial_gPrim_of_Phis[index] = calc_partial_gPrim_of_Phi(
		env,
		TPrims,
		gPrims,
		GammaULLs,
		EFEs,
		i
	);

#if 0
	//scale up our gradient?
	//scale by c^4 / G ~ 1e+44
	// which is the units of conversion
	//c^4/G * G_ab = 8 Ï€ T_ab
	// but why not just do this in the lambda?
	partial_gPrim_of_Phis[index].alpha *= c*c*c*c/G;
	partial_gPrim_of_Phis[index].betaU = partial_gPrim_of_Phis[index].betaU * (c*c*c*c/G);
	partial_gPrim_of_Phis[index].gammaLL = partial_gPrim_of_Phis[index].gammaLL * (c*c*c*c/G);
#endif
}

kernel void update_gPrims(
	constant env_t const * const env,
	global gPrim_t * const gPrims,
	global gPrim_t const * const partial_gPrim_of_Phis,
	real const updateLambda
) {
	initKernel();
	auto & gPrim = gPrims[index];
	auto const & partial_gPrim_of_Phi = partial_gPrim_of_Phis[index];

	if (env->convergeAlpha) {
		gPrim.alpha -= partial_gPrim_of_Phi.alpha * updateLambda;
	}
	if (env->convergeBeta) {
		gPrim.betaU -= partial_gPrim_of_Phi.betaU * updateLambda;
	}
	if (env->convergeGamma) {
		gPrim.gammaLL -= partial_gPrim_of_Phi.gammaLL * updateLambda;
	}
}
